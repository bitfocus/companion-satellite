import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'

const modulesDir = fileURLToPath(new URL('../modules', import.meta.url))
const outputPath = fileURLToPath(new URL('../satellite/src/generated/bundled-modules.ts', import.meta.url))

interface ManifestInfo {
	id: string
	name: string
	shortname: string
	runtime: {
		type: string
		apiVersion: string
		entrypoint: string
	}
}

interface ModuleInfo {
	dirName: string
	manifest: ManifestInfo
	relativePath: string
}

function getModules(): ModuleInfo[] {
	const modules: ModuleInfo[] = []

	if (!fs.existsSync(modulesDir)) {
		console.log('No modules directory found')
		return modules
	}

	const entries = fs.readdirSync(modulesDir, { withFileTypes: true })

	for (const entry of entries) {
		if (!entry.isDirectory()) continue
		if (!entry.name.startsWith('companion-surface-')) continue

		const modulePath = path.join(modulesDir, entry.name)
		const manifestPath = path.join(modulePath, 'companion', 'manifest.json')

		if (!fs.existsSync(manifestPath)) {
			console.log(`Skipping ${entry.name}: no manifest.json found`)
			continue
		}

		try {
			const manifestContent = fs.readFileSync(manifestPath, 'utf8')
			const manifest = JSON.parse(manifestContent) as ManifestInfo

			// Verify it's a surface module
			if ((manifest as any).type !== 'surface') {
				console.log(`Skipping ${entry.name}: not a surface module`)
				continue
			}

			modules.push({
				dirName: entry.name,
				manifest,
				relativePath: `#modules/${entry.name}`,
			})
		} catch (error) {
			console.error(`Error reading manifest for ${entry.name}:`, error)
		}
	}

	// Sort by id for consistent output
	return modules.sort((a, b) => a.manifest.id.localeCompare(b.manifest.id))
}

function generateVariableName(id: string): string {
	// Convert kebab-case to PascalCase
	let name = id
		.split('-')
		.map((part) => part.charAt(0).toUpperCase() + part.slice(1))
		.join('')

	// Variable names can't start with a number - prefix with underscore
	if (/^\d/.test(name)) {
		name = '_' + name
	}

	return name
}

function generateCode(modules: ModuleInfo[]): string {
	const lines: string[] = []

	lines.push('// Auto-generated file - do not edit manually')
	lines.push('// Generated by tools/generate-module-index.mts')
	lines.push('')
	lines.push("import type { SurfacePlugin } from '@companion-surface/base'")
	lines.push('')

	// Generate imports for each module using path aliases
	for (const module of modules) {
		const varName = generateVariableName(module.manifest.id) + 'Plugin'
		const manifestVarName = generateVariableName(module.manifest.id) + 'Manifest'

		lines.push(`import ${varName} from '${module.relativePath}/plugin'`)
		lines.push(`import ${manifestVarName} from '${module.relativePath}/manifest' with { type: 'json' }`)
		lines.push('')
	}

	// Generate the interface for bundled modules
	lines.push('export interface BundledModule {')
	lines.push('\tmanifest: {')
	lines.push('\t\tid: string')
	lines.push('\t\tname: string')
	lines.push('\t\tshortname: string')
	lines.push('\t\truntime: {')
	lines.push('\t\t\ttype: string')
	lines.push('\t\t\tapiVersion: string')
	lines.push('\t\t\tentrypoint: string')
	lines.push('\t\t}')
	lines.push('\t}')
	lines.push('\tplugin: SurfacePlugin<unknown>')
	lines.push('}')
	lines.push('')

	// Generate the bundled modules array
	lines.push('export const bundledModules: BundledModule[] = [')

	for (const module of modules) {
		const varName = generateVariableName(module.manifest.id) + 'Plugin'
		const manifestVarName = generateVariableName(module.manifest.id) + 'Manifest'

		lines.push('\t{')
		lines.push(`\t\tmanifest: ${manifestVarName},`)
		lines.push(`\t\tplugin: ${varName},`)
		lines.push('\t},')
	}

	lines.push(']')
	lines.push('')

	return lines.join('\n')
}

function main() {
	console.log('Generating module index...\n')

	const modules = getModules()

	if (modules.length === 0) {
		console.log('No modules found')

		// Generate empty file
		const emptyCode = `// Auto-generated file - do not edit manually
// Generated by tools/generate-module-index.mts
// No modules found

import type { SurfacePlugin } from '@companion-surface/base'

export interface BundledModule {
\tmanifest: {
\t\tid: string
\t\tname: string
\t\tshortname: string
\t\truntime: {
\t\t\ttype: string
\t\t\tapiVersion: string
\t\t\tentrypoint: string
\t\t}
\t}
\tplugin: SurfacePlugin<unknown>
}

export const bundledModules: BundledModule[] = []
`
		fs.writeFileSync(outputPath, emptyCode, 'utf8')
		console.log(`Generated empty module index at: ${outputPath}`)
		return
	}

	console.log(`Found ${modules.length} modules:`)
	for (const module of modules) {
		console.log(`  - ${module.manifest.id} (${module.manifest.name})`)
	}

	const code = generateCode(modules)

	// Ensure the output directory exists
	const outputDir = path.dirname(outputPath)
	if (!fs.existsSync(outputDir)) {
		fs.mkdirSync(outputDir, { recursive: true })
	}

	fs.writeFileSync(outputPath, code, 'utf8')
	console.log(`\nGenerated module index at: ${outputPath}`)
}

main()
